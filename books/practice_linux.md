linuxのしくみ

・ハイパースレッディング

1つのcpuを擬似的に2つに見せる技術

cpuは最強に早いがメモリやレジスタアクセスがネック。ならレジスタを複数積んだりしてCPUを有効活用、擬似的にcpu複数に見せればいいって話







・プロセスの状態

実行(R)

実行待ち(R)

スリープ(S or D)　> 入力待ちとか

ゾンビ(Z)　

4つ覚えておけば良い。

CPU上で、何もすることがないと、cpu はアイドルプロセスを実行(何もしないプロセス)



・レイテンシ

処理を完了するまでの時間。短いほど良い。

アイドル状態が0であれば、レイテンシ、スループットは最大化される

基本的にはスループットとレイテンシはトレードオフ(実行待ちプロセスがある=処理の完了までに必要なプロセスが多い、とレイテンシは長くなる、スループットはアイドル状態がなくなるので高くなる)

※sar -q  で runq-sz フィールドを表示すると、Rを表示できる





・ロードバランサ

複数のcpuがあった場合、プロセスの割り当てをコントロールするのもロードバランサと呼ばれる

cf) /proc/cpuinfo

cpuの情報が格納されてる。



・マルチコアcpuは複数プロセス処理しないと性能は上がらない

性能n倍は、理論値である。



・time コマンド

プログラムの開始終了時刻を出せる

経過時間(real)   プログラムにかかった時間

使用時間(user+sys) プロセスがcpuを使った時間

cf) ps -eo pid, etime, time でもみれる

etime=elapsed time

time =使用時間

eo オプションはユーザーが引数として渡したプロセスの情報を出してくれる。



・free コマンド

引数なし実行で、メモリー状況を確認できる。

total フィールド

システムの全メモリの量

freeフィールド

見かけ上空いてるメモリ量

buff/cacheフィールド

freeが減少してきた場合、カーネルによって解放される

(linuxは主にIO高速化のためにこのメモリをキャッシュに利用している、空きメモリがあればどんどんこのbuff/cacheは増える)

available フィールド

free + やばい時解放できる部分全て

cf)OOM killer

メモリが完全になくなった時、適当なプロセスを強制終了させる機能、怖い。



・メモリを割り当てるタイミング

1.プロセス生成時

2.プロセス生成後、追加で動的に割り当てる

(プロセスがシステムコールで要求する)



・仮想メモリ

cf)ページテーブル

仮想メモリと物理メモリの対応表

すべてのメモリはページ毎に区切られる

>>利点

1.仮装にすると断片化してもページテーブルがあるから有効活用できる

IMG_7233.jpeg

2.他プロセスの領域に入り込むことがない

ページテーブルはプロセスごとに作成され、プログラムからはページテーブルの中しか見えないから。(物理アドレスを直接確保できない)

※メモリを増加させたいときは、システムコールで要求するワンクッションを挟むので、干渉しないよう制御してくれる。



IMG_7234.jpeg



・MMU Memory Management Unit

ページテーブルを管理、メモリを監督してくれるやつ。カーネルの中の一部。





・mmap システムコール

メモリを追加確保するためのコール

ページ単位でしか確保ができないので、プログラムなどによっては、ページ単位で確保したものをプールしておき、そこから渡して細かくメモリ管理する。みたいなことできる。





ファイルマップ

linuxではファイルを開くとmmapにてメモリに展開する。保存する時に、memcpy にてストレージへ保存する



・デマンドページング

物理メモリの確保は、実際に仮想メモリからアクセスがあって初めて確保される方式

(だから最初の物理メモリのアクセスにはページフォルト割り込みが絶対起こる？)

>>これ、結局仮想メモリは物理メモリを予約しておかないといけないから意味薄くない？

>予約じゃないんやわ、仮想メモリを実際に使おうとした時、初めて物理メモリにアクセスして必要な分だけとってきてくれる、、のね。

cf)仮装メモリの枯渇

>仮装メモリも枯渇しうるが、最近は起きない。仮装アドレス空間が足りなくなると起きる。

物



https://elinux.org/images/3/31/Virtual_memory_20070222.pdf



・コピーオンライト copy on write

fork でプロセス生成する時親プロセスと子プロセスはページテーブルだけをコピーする

このとき親子双方の書き込み権限を奪う

=読み取り専用にて共通の物理アドレスを見る。

IMG_7239.jpeg

>>どちらかが書き込みをすると、ページフォルトし、書き込もうとしたページ分だけ、親子別々でメモリを割り当てる。

(つまり、書き込みをしない限りメモリは大幅には増えない)



・swapon --show コマンド

スワップ領域を確認できる。

free の Swap: フィールドも同様

sar -W でスワッピングの発生を監視できる。

cf)メジャーフォルト

>ストレージへのアクセスが起きるページフォルト

>マイナーフォルト

アクセスの起きないページフォルト



・仮想アドレスの節約

階層構造にすることで節約している



・ヒュージページ

普通よりサイズの大きなページ

ページ使用が多くなると、管理のための仮装アドレスが物理メモリを圧迫してしまう

なので、ページを大きく区切ったものを使用する

>forkを高速化できる、メモリ節約

cf)トランスペアレントヒュージページ

一定条件でページが連続したとき、勝手にlinuxでヒュージページにまとめてくれる

ただ解除もされるので、局所的に性能が下がることもある。



・キャッシュメモリは階層構造

近さで分かれており、L1,L2,L3と分かれている。

cf)参照の局所性

時間的> ループ処理すると変数にもっかいすぐアクセスするね

空間的>配列処理ですぐ近くにアクセスするね

だから狭い範囲のキャッシュが有効なのよ

>>つまりこのメモリアクセスを考慮するとプログラムは高速化できる？？

cf2)TLB Translation Lookaside Buffer

ページテーブルをキャッシュしとくキャッシュメモリ。

(仮装アドレスから物理アドレスを参照するにはページテーブルを見るが、そのためには物理アドレスを参照するのでキャッシュメモリが意味がなくなる、だからページテーブルもキャッシュするTLB領域が必要)



・ページキャッシュ

キャッシュメモリとページキャッシュは別！！

キャッシュメモリはメモリ>キャッシュメモリ(キャッシュライン単位)

ページキャッシュはストレージ>メモリ

(ページ単位)

カーネル内のページキャッシュ領域へキャッシュしておく。free の buff/cache がこれか

ページの開放はダーティーでないページ、ダーティーページの順となる。

ダーティーページのライトバックが多発すると非常にプログラムの質が悪くなる。



・O_SYNC(同期書き込み)

キャッシュにあるデータはライトバックされる前に電源が落ちると消える。

なので書き込んだはずなのに！が起きる。

これを防ぐにはopenシステムコール時にオプションでO_SYNC を付けると、同期的に書き込みしてくれる。



・vm.dirty_writeback_centisecs

ライトバックをどれくらいの周期で行うかの設定

vm.dirty_writeback_ratio

容量で判別してライトバックするもの



・linux はストレージデバイスにファイルシステムを使用してアクセスする。

ファイルシステムがないと、メモリのどのアドレスに書いたかを自分で覚えておかないといけなくなる。





・クォータ

システム管理のためのプロセスが容量不足に陥らないよう、用途ごとに使用できるフォイルシステムの容量を制限する仕組み。



・アトミックな処理

トランザクションなどにおいてこれ以上分割できない処理



・ジャーナル

ファイルなどの更新の際に、ジャーナルと呼ばれるファイルに、更新するアトミックな処理を記述してから操作を行う。

ジャーナル更新中エラー>何も無かったことにする

ジャーナル更新後エラー>ジャーナルに従って操作を行う



・fsck 

これは git push -f に似てる。

無理やりファイルシステムをマウントするように調整するだけのもの。非推奨。

定期的なバックアップがNo1

(不整合が起きたファイルシステムはマウントできなくなる？)



・デバイスファイル　

デバイスをファイル化して操作する。(/dev以下)

基本的にread, write などのシステムコールでアクセスする。rootユーザーのみが基本。

cf)キャラクタデバイス、ブロックデバイス



キャラクタデバイス(=端末、パソコン？)

読み書きok、シークNG

実際の端末とかはこれ。

誤解してた、ファイルシステムが乗っかる端末もファイルシステムにマウントして操作するんだわ。

普段のbash上の操作もデバイスファイルの操作に変換されている。



ブロックデバイス(=HDD,SDD)

読み書き以外にランダムアクセスができる。

parted, dd などは直接ブロックデバイスを操作するためのコマンド

使い方>>

書き込み(直接書き換えるのは本来危険！

普通はファイルシステムを作成して間接的にアクセスする)

ファイル作成　mkfs.ext4 /dev/sdc7
マウント　mount /dev/sdc7 /mnt/
echo "hello" > /mnt/testfile
ls /mnt/         lost+found testfile(lost+foundは元々入ってる)
cat /mnt/testfile        hello
unmount /mnt/


・strings コマンド

strings -t x にて、ファイルオフセットと文字列を表示できる。



・tmpfs

メモリ上の作る仮のファイルシステム

高速だが、電源落としたら消える。

/tmp や /var/run などに使われる

cf) nfs,cifs

ネットワークファイルシステム、リモートのネットワーク環境でのファイルシステム



・procfs

プロセスについてのファイルシステム

各プロセスの情報が見れる

/proc以下にマウント

cf)sysfs

システムについての情報

sys以下にマウント



・cgroup

プロセスやプロセス群のグループに対してリソース使用量の制限をかけるもの

cgroupfsを使用して操作する



・スナップショット

なぜフルバックアップより速いのか？

>>データを参照するメタデータ作成とダーティページのライトバックのみで済むから。

(だから、元のシステム自体が完全に失われるとスナップショットでは再現できない、、？)

IMG_7259.jpeg



・ストレージが遅い理由

スイングアームとプラッタを物理的に動かさなきゃいけないから。

シーケンシャルアクセスが速いのも、連続した領域ならプラッタの稼働が少ない、まとめてアクセスすればプラッタ稼働が少ない

ただ、まとめてアクセスには限界もある(HDD側の一回の読み出し量の限界値)



・I/Oスケジューラ

I/O要求を一定バッファし、ソート(連続セクタへのアクセスをまとめる)・マージ(不連続なセクタへのアクセスを番号順に並べ替える)を行い、性能を高める





・先読み　read-ahead

空間的局所性を利用し、連続したセクタのデータを読んでおく。



・SSD

機械的な動作がない(プラッタとスイングアームがない？)電気信号のみでのストレージデバイス



ストレージへのアクセスまとめ

・ファイル内のデータを連続する、あるいは近い領域に配置する。 

・連続する領域へのアクセスは、複数回に分けずにひとまとめにする。 

・ファイルには、なるべく大きなサイズでシーケンシャルアクセスをする。